/* automatically generated by rust-bindgen */

pub const RTCORE_VERSION_MAJOR: ::std::os::raw::c_uint = 2;
pub const RTCORE_VERSION_MINOR: ::std::os::raw::c_uint = 16;
pub const RTCORE_VERSION_PATCH: ::std::os::raw::c_uint = 1;
pub const RTCORE_VERSION: ::std::os::raw::c_uint = 21601;
pub const RTCORE_VERSION_STRING: &'static [u8; 7usize] = b"2.16.1\x00";
pub const RTC_MAX_TIME_STEPS: ::std::os::raw::c_uint = 129;
pub const RTC_MAX_USER_VERTEX_BUFFERS: ::std::os::raw::c_uint = 16;
pub const RTC_MAX_INDEX_BUFFERS: ::std::os::raw::c_uint = 16;
pub type __ssize_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCBounds {
    pub lower_x: f32,
    pub lower_y: f32,
    pub lower_z: f32,
    pub align0: f32,
    pub upper_x: f32,
    pub upper_y: f32,
    pub upper_z: f32,
    pub align1: f32,
}
#[test]
fn bindgen_test_layout_RTCBounds() {
    assert_eq!(::std::mem::size_of::<RTCBounds>() , 32usize , concat ! (
               "Size of: " , stringify ! ( RTCBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . lower_x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( lower_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . lower_y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( lower_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . lower_z as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( lower_z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . align0 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( align0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . upper_x as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( upper_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . upper_y as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( upper_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . upper_z as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( upper_z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBounds ) ) . align1 as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBounds ) , "::" ,
                stringify ! ( align1 ) ));
}
impl Clone for RTCBounds {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __RTCDevice {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___RTCDevice() {
    assert_eq!(::std::mem::size_of::<__RTCDevice>() , 1usize , concat ! (
               "Size of: " , stringify ! ( __RTCDevice ) ));
    assert_eq! (::std::mem::align_of::<__RTCDevice>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( __RTCDevice ) ));
}
impl Clone for __RTCDevice {
    fn clone(&self) -> Self { *self }
}
pub type RTCDevice = *mut __RTCDevice;
extern "C" {
    pub fn rtcNewDevice(cfg: *const ::std::os::raw::c_char) -> RTCDevice;
}
extern "C" {
    pub fn rtcDeleteDevice(device: RTCDevice);
}
extern "C" {
    pub fn rtcInit(cfg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rtcExit();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCParameter {
    RTC_SOFTWARE_CACHE_SIZE = 0,
    RTC_CONFIG_INTERSECT1 = 1,
    RTC_CONFIG_INTERSECT4 = 2,
    RTC_CONFIG_INTERSECT8 = 3,
    RTC_CONFIG_INTERSECT16 = 4,
    RTC_CONFIG_INTERSECT_STREAM = 5,
    RTC_CONFIG_RAY_MASK = 6,
    RTC_CONFIG_BACKFACE_CULLING = 7,
    RTC_CONFIG_INTERSECTION_FILTER = 8,
    RTC_CONFIG_INTERSECTION_FILTER_RESTORE = 9,
    RTC_CONFIG_IGNORE_INVALID_RAYS = 11,
    RTC_CONFIG_TASKING_SYSTEM = 12,
    RTC_CONFIG_VERSION_MAJOR = 13,
    RTC_CONFIG_VERSION_MINOR = 14,
    RTC_CONFIG_VERSION_PATCH = 15,
    RTC_CONFIG_VERSION = 16,
    RTC_CONFIG_TRIANGLE_GEOMETRY = 17,
    RTC_CONFIG_QUAD_GEOMETRY = 18,
    RTC_CONFIG_LINE_GEOMETRY = 19,
    RTC_CONFIG_HAIR_GEOMETRY = 20,
    RTC_CONFIG_SUBDIV_GEOMETRY = 21,
    RTC_CONFIG_USER_GEOMETRY = 22,
    RTC_CONFIG_COMMIT_JOIN = 23,
    RTC_CONFIG_COMMIT_THREAD = 24,
}
extern "C" {
    pub fn rtcSetParameter1i(parm: RTCParameter, val: isize);
}
extern "C" {
    pub fn rtcGetParameter1i(parm: RTCParameter) -> isize;
}
extern "C" {
    pub fn rtcDeviceSetParameter1i(device: RTCDevice, parm: RTCParameter,
                                   val: isize);
}
extern "C" {
    pub fn rtcDeviceGetParameter1i(device: RTCDevice, parm: RTCParameter)
     -> isize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCError {
    RTC_NO_ERROR = 0,
    RTC_UNKNOWN_ERROR = 1,
    RTC_INVALID_ARGUMENT = 2,
    RTC_INVALID_OPERATION = 3,
    RTC_OUT_OF_MEMORY = 4,
    RTC_UNSUPPORTED_CPU = 5,
    RTC_CANCELLED = 6,
}
extern "C" {
    pub fn rtcGetError() -> RTCError;
}
extern "C" {
    pub fn rtcDeviceGetError(device: RTCDevice) -> RTCError;
}
pub type RTCErrorFunc =
    ::std::option::Option<unsafe extern "C" fn(code: RTCError,
                                               str:
                                                   *const ::std::os::raw::c_char)>;
pub type RTC_ERROR_FUNCTION = RTCErrorFunc;
pub type RTCErrorFunc2 =
    ::std::option::Option<unsafe extern "C" fn(userPtr:
                                                   *mut ::std::os::raw::c_void,
                                               code: RTCError,
                                               str:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn rtcSetErrorFunction(func: RTCErrorFunc);
}
extern "C" {
    pub fn rtcDeviceSetErrorFunction(device: RTCDevice, func: RTCErrorFunc);
}
extern "C" {
    pub fn rtcDeviceSetErrorFunction2(device: RTCDevice, func: RTCErrorFunc2,
                                      userPtr: *mut ::std::os::raw::c_void);
}
pub type RTCMemoryMonitorFunc =
    ::std::option::Option<unsafe extern "C" fn(bytes: isize, post: bool)
                              -> bool>;
pub type RTC_MEMORY_MONITOR_FUNCTION = RTCMemoryMonitorFunc;
pub type RTCMemoryMonitorFunc2 =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               bytes: isize, post: bool)
                              -> bool>;
extern "C" {
    pub fn rtcSetMemoryMonitorFunction(func: RTCMemoryMonitorFunc);
}
extern "C" {
    pub fn rtcDeviceSetMemoryMonitorFunction(device: RTCDevice,
                                             func: RTCMemoryMonitorFunc);
}
extern "C" {
    pub fn rtcDeviceSetMemoryMonitorFunction2(device: RTCDevice,
                                              func: RTCMemoryMonitorFunc2,
                                              userPtr:
                                                  *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rtcDebug();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRay {
    pub org: [f32; 3usize],
    pub align0: f32,
    pub dir: [f32; 3usize],
    pub align1: f32,
    pub tnear: f32,
    pub tfar: f32,
    pub time: f32,
    pub mask: ::std::os::raw::c_uint,
    pub Ng: [f32; 3usize],
    pub align2: f32,
    pub u: f32,
    pub v: f32,
    pub geomID: ::std::os::raw::c_uint,
    pub primID: ::std::os::raw::c_uint,
    pub instID: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_RTCRay() {
    assert_eq!(::std::mem::size_of::<RTCRay>() , 96usize , concat ! (
               "Size of: " , stringify ! ( RTCRay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . org as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( org ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . align0 as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( align0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . dir as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . align1 as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . tnear as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( tnear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . tfar as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( tfar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . time as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . mask as * const _ as usize }
                , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . Ng as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( Ng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . align2 as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( align2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . u as * const _ as usize } ,
                64usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . v as * const _ as usize } ,
                68usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . geomID as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . primID as * const _ as usize
                } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( primID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay ) ) . instID as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay ) , "::" ,
                stringify ! ( instID ) ));
}
impl Clone for RTCRay {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRay4 {
    pub orgx: [f32; 4usize],
    pub orgy: [f32; 4usize],
    pub orgz: [f32; 4usize],
    pub dirx: [f32; 4usize],
    pub diry: [f32; 4usize],
    pub dirz: [f32; 4usize],
    pub tnear: [f32; 4usize],
    pub tfar: [f32; 4usize],
    pub time: [f32; 4usize],
    pub mask: [::std::os::raw::c_uint; 4usize],
    pub Ngx: [f32; 4usize],
    pub Ngy: [f32; 4usize],
    pub Ngz: [f32; 4usize],
    pub u: [f32; 4usize],
    pub v: [f32; 4usize],
    pub geomID: [::std::os::raw::c_uint; 4usize],
    pub primID: [::std::os::raw::c_uint; 4usize],
    pub instID: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_RTCRay4() {
    assert_eq!(::std::mem::size_of::<RTCRay4>() , 288usize , concat ! (
               "Size of: " , stringify ! ( RTCRay4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . orgx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( orgx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . orgy as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( orgy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . orgz as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( orgz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . dirx as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( dirx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . diry as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( diry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . dirz as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( dirz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . tnear as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( tnear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . tfar as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( tfar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . time as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . mask as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . Ngx as * const _ as usize }
                , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( Ngx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . Ngy as * const _ as usize }
                , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( Ngy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . Ngz as * const _ as usize }
                , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( Ngz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . u as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . v as * const _ as usize } ,
                224usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . geomID as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . primID as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( primID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay4 ) ) . instID as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay4 ) , "::" ,
                stringify ! ( instID ) ));
}
impl Clone for RTCRay4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRay8 {
    pub orgx: [f32; 8usize],
    pub orgy: [f32; 8usize],
    pub orgz: [f32; 8usize],
    pub dirx: [f32; 8usize],
    pub diry: [f32; 8usize],
    pub dirz: [f32; 8usize],
    pub tnear: [f32; 8usize],
    pub tfar: [f32; 8usize],
    pub time: [f32; 8usize],
    pub mask: [::std::os::raw::c_uint; 8usize],
    pub Ngx: [f32; 8usize],
    pub Ngy: [f32; 8usize],
    pub Ngz: [f32; 8usize],
    pub u: [f32; 8usize],
    pub v: [f32; 8usize],
    pub geomID: [::std::os::raw::c_uint; 8usize],
    pub primID: [::std::os::raw::c_uint; 8usize],
    pub instID: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_RTCRay8() {
    assert_eq!(::std::mem::size_of::<RTCRay8>() , 576usize , concat ! (
               "Size of: " , stringify ! ( RTCRay8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . orgx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( orgx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . orgy as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( orgy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . orgz as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( orgz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . dirx as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( dirx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . diry as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( diry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . dirz as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( dirz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . tnear as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( tnear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . tfar as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( tfar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . time as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . mask as * const _ as usize
                } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . Ngx as * const _ as usize }
                , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( Ngx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . Ngy as * const _ as usize }
                , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( Ngy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . Ngz as * const _ as usize }
                , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( Ngz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . u as * const _ as usize } ,
                416usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . v as * const _ as usize } ,
                448usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . geomID as * const _ as
                usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . primID as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( primID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay8 ) ) . instID as * const _ as
                usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay8 ) , "::" ,
                stringify ! ( instID ) ));
}
impl Clone for RTCRay8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRay16 {
    pub orgx: [f32; 16usize],
    pub orgy: [f32; 16usize],
    pub orgz: [f32; 16usize],
    pub dirx: [f32; 16usize],
    pub diry: [f32; 16usize],
    pub dirz: [f32; 16usize],
    pub tnear: [f32; 16usize],
    pub tfar: [f32; 16usize],
    pub time: [f32; 16usize],
    pub mask: [::std::os::raw::c_uint; 16usize],
    pub Ngx: [f32; 16usize],
    pub Ngy: [f32; 16usize],
    pub Ngz: [f32; 16usize],
    pub u: [f32; 16usize],
    pub v: [f32; 16usize],
    pub geomID: [::std::os::raw::c_uint; 16usize],
    pub primID: [::std::os::raw::c_uint; 16usize],
    pub instID: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_RTCRay16() {
    assert_eq!(::std::mem::size_of::<RTCRay16>() , 1152usize , concat ! (
               "Size of: " , stringify ! ( RTCRay16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . orgx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( orgx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . orgy as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( orgy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . orgz as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( orgz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . dirx as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( dirx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . diry as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( diry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . dirz as * const _ as usize
                } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( dirz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . tnear as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( tnear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . tfar as * const _ as usize
                } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( tfar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . time as * const _ as usize
                } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . mask as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . Ngx as * const _ as usize
                } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( Ngx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . Ngy as * const _ as usize
                } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( Ngy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . Ngz as * const _ as usize
                } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( Ngz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . u as * const _ as usize }
                , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . v as * const _ as usize }
                , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . geomID as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . primID as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( primID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRay16 ) ) . instID as * const _ as
                usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRay16 ) , "::" ,
                stringify ! ( instID ) ));
}
impl Clone for RTCRay16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRayNp {
    pub orgx: *mut f32,
    pub orgy: *mut f32,
    pub orgz: *mut f32,
    pub dirx: *mut f32,
    pub diry: *mut f32,
    pub dirz: *mut f32,
    pub tnear: *mut f32,
    pub tfar: *mut f32,
    pub time: *mut f32,
    pub mask: *mut ::std::os::raw::c_uint,
    pub Ngx: *mut f32,
    pub Ngy: *mut f32,
    pub Ngz: *mut f32,
    pub u: *mut f32,
    pub v: *mut f32,
    pub geomID: *mut ::std::os::raw::c_uint,
    pub primID: *mut ::std::os::raw::c_uint,
    pub instID: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_RTCRayNp() {
    assert_eq!(::std::mem::size_of::<RTCRayNp>() , 144usize , concat ! (
               "Size of: " , stringify ! ( RTCRayNp ) ));
    assert_eq! (::std::mem::align_of::<RTCRayNp>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( RTCRayNp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . orgx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( orgx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . orgy as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( orgy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . orgz as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( orgz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . dirx as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( dirx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . diry as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( diry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . dirz as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( dirz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . tnear as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( tnear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . tfar as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( tfar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . time as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . mask as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . Ngx as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( Ngx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . Ngy as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( Ngy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . Ngz as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( Ngz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . u as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . v as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . geomID as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . primID as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( primID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCRayNp ) ) . instID as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCRayNp ) , "::" ,
                stringify ! ( instID ) ));
}
impl Clone for RTCRayNp {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCSceneFlags {
    RTC_SCENE_STATIC = 0,
    RTC_SCENE_DYNAMIC = 1,
    RTC_SCENE_COMPACT = 256,
    RTC_SCENE_COHERENT = 512,
    RTC_SCENE_INCOHERENT = 1024,
    RTC_SCENE_HIGH_QUALITY = 2048,
    RTC_SCENE_ROBUST = 65536,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCAlgorithmFlags {
    RTC_INTERSECT1 = 1,
    RTC_INTERSECT4 = 2,
    RTC_INTERSECT8 = 4,
    RTC_INTERSECT16 = 8,
    RTC_INTERPOLATE = 16,
    RTC_INTERSECT_STREAM = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCIntersectFlags {
    RTC_INTERSECT_COHERENT = 0,
    RTC_INTERSECT_INCOHERENT = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCIntersectContext {
    pub flags: RTCIntersectFlags,
    pub userRayExt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RTCIntersectContext() {
    assert_eq!(::std::mem::size_of::<RTCIntersectContext>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( RTCIntersectContext ) ));
    assert_eq! (::std::mem::align_of::<RTCIntersectContext>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( RTCIntersectContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCIntersectContext ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCIntersectContext ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCIntersectContext ) ) . userRayExt as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCIntersectContext ) ,
                "::" , stringify ! ( userRayExt ) ));
}
impl Clone for RTCIntersectContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __RTCScene {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___RTCScene() {
    assert_eq!(::std::mem::size_of::<__RTCScene>() , 1usize , concat ! (
               "Size of: " , stringify ! ( __RTCScene ) ));
    assert_eq! (::std::mem::align_of::<__RTCScene>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( __RTCScene ) ));
}
impl Clone for __RTCScene {
    fn clone(&self) -> Self { *self }
}
pub type RTCScene = *mut __RTCScene;
extern "C" {
    pub fn rtcNewScene(flags: RTCSceneFlags, aflags: RTCAlgorithmFlags)
     -> RTCScene;
}
extern "C" {
    pub fn rtcDeviceNewScene(device: RTCDevice, flags: RTCSceneFlags,
                             aflags: RTCAlgorithmFlags) -> RTCScene;
}
pub type RTCProgressMonitorFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               n: f64) -> bool>;
pub type RTC_PROGRESS_MONITOR_FUNCTION = RTCProgressMonitorFunc;
extern "C" {
    pub fn rtcSetProgressMonitorFunction(scene: RTCScene,
                                         func: RTCProgressMonitorFunc,
                                         ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rtcCommit(scene: RTCScene);
}
extern "C" {
    pub fn rtcCommitJoin(scene: RTCScene);
}
extern "C" {
    pub fn rtcCommitThread(scene: RTCScene, threadID: ::std::os::raw::c_uint,
                           numThreads: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rtcGetBounds(scene: RTCScene, bounds_o: *mut RTCBounds);
}
extern "C" {
    pub fn rtcGetLinearBounds(scene: RTCScene, bounds_o: *mut RTCBounds);
}
extern "C" {
    pub fn rtcIntersect(scene: RTCScene, ray: *mut RTCRay);
}
extern "C" {
    pub fn rtcIntersect1Ex(scene: RTCScene,
                           context: *const RTCIntersectContext,
                           ray: *mut RTCRay);
}
extern "C" {
    pub fn rtcIntersect4(valid: *const ::std::os::raw::c_void,
                         scene: RTCScene, ray: *mut RTCRay4);
}
extern "C" {
    pub fn rtcIntersect4Ex(valid: *const ::std::os::raw::c_void,
                           scene: RTCScene,
                           context: *const RTCIntersectContext,
                           ray: *mut RTCRay4);
}
extern "C" {
    pub fn rtcIntersect8(valid: *const ::std::os::raw::c_void,
                         scene: RTCScene, ray: *mut RTCRay8);
}
extern "C" {
    pub fn rtcIntersect8Ex(valid: *const ::std::os::raw::c_void,
                           scene: RTCScene,
                           context: *const RTCIntersectContext,
                           ray: *mut RTCRay8);
}
extern "C" {
    pub fn rtcIntersect16(valid: *const ::std::os::raw::c_void,
                          scene: RTCScene, ray: *mut RTCRay16);
}
extern "C" {
    pub fn rtcIntersect16Ex(valid: *const ::std::os::raw::c_void,
                            scene: RTCScene,
                            context: *const RTCIntersectContext,
                            ray: *mut RTCRay16);
}
extern "C" {
    pub fn rtcIntersect1M(scene: RTCScene,
                          context: *const RTCIntersectContext,
                          rays: *mut RTCRay, M: usize, stride: usize);
}
extern "C" {
    pub fn rtcIntersect1Mp(scene: RTCScene,
                           context: *const RTCIntersectContext,
                           rays: *mut *mut RTCRay, M: usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCRayN {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_RTCRayN() {
    assert_eq!(::std::mem::size_of::<RTCRayN>() , 1usize , concat ! (
               "Size of: " , stringify ! ( RTCRayN ) ));
    assert_eq! (::std::mem::align_of::<RTCRayN>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( RTCRayN ) ));
}
impl Clone for RTCRayN {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rtcIntersectNM(scene: RTCScene,
                          context: *const RTCIntersectContext,
                          rays: *mut RTCRayN, N: usize, M: usize,
                          stride: usize);
}
extern "C" {
    pub fn rtcIntersectNp(scene: RTCScene,
                          context: *const RTCIntersectContext,
                          rays: *const RTCRayNp, N: usize);
}
extern "C" {
    pub fn rtcOccluded(scene: RTCScene, ray: *mut RTCRay);
}
extern "C" {
    pub fn rtcOccluded1Ex(scene: RTCScene,
                          context: *const RTCIntersectContext,
                          ray: *mut RTCRay);
}
extern "C" {
    pub fn rtcOccluded4(valid: *const ::std::os::raw::c_void, scene: RTCScene,
                        ray: *mut RTCRay4);
}
extern "C" {
    pub fn rtcOccluded4Ex(valid: *const ::std::os::raw::c_void,
                          scene: RTCScene,
                          context: *const RTCIntersectContext,
                          ray: *mut RTCRay4);
}
extern "C" {
    pub fn rtcOccluded8(valid: *const ::std::os::raw::c_void, scene: RTCScene,
                        ray: *mut RTCRay8);
}
extern "C" {
    pub fn rtcOccluded8Ex(valid: *const ::std::os::raw::c_void,
                          scene: RTCScene,
                          context: *const RTCIntersectContext,
                          ray: *mut RTCRay8);
}
extern "C" {
    pub fn rtcOccluded16(valid: *const ::std::os::raw::c_void,
                         scene: RTCScene, ray: *mut RTCRay16);
}
extern "C" {
    pub fn rtcOccluded16Ex(valid: *const ::std::os::raw::c_void,
                           scene: RTCScene,
                           context: *const RTCIntersectContext,
                           ray: *mut RTCRay16);
}
extern "C" {
    pub fn rtcOccluded1M(scene: RTCScene, context: *const RTCIntersectContext,
                         rays: *mut RTCRay, M: usize, stride: usize);
}
extern "C" {
    pub fn rtcOccluded1Mp(scene: RTCScene,
                          context: *const RTCIntersectContext,
                          rays: *mut *mut RTCRay, M: usize);
}
extern "C" {
    pub fn rtcOccludedNM(scene: RTCScene, context: *const RTCIntersectContext,
                         rays: *mut RTCRayN, N: usize, M: usize,
                         stride: usize);
}
extern "C" {
    pub fn rtcOccludedNp(scene: RTCScene, context: *const RTCIntersectContext,
                         rays: *const RTCRayNp, N: usize);
}
extern "C" {
    pub fn rtcDeleteScene(scene: RTCScene);
}
pub const RTCBufferType_RTC_INDEX_BUFFER0: RTCBufferType =
    RTCBufferType::RTC_INDEX_BUFFER;
pub const RTCBufferType_RTC_VERTEX_BUFFER0: RTCBufferType =
    RTCBufferType::RTC_VERTEX_BUFFER;
pub const RTCBufferType_RTC_USER_VERTEX_BUFFER0: RTCBufferType =
    RTCBufferType::RTC_USER_VERTEX_BUFFER;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCBufferType {
    RTC_INDEX_BUFFER = 16777216,
    RTC_INDEX_BUFFER1 = 16777217,
    RTC_VERTEX_BUFFER = 33554432,
    RTC_VERTEX_BUFFER1 = 33554433,
    RTC_USER_VERTEX_BUFFER = 34603008,
    RTC_USER_VERTEX_BUFFER1 = 34603009,
    RTC_FACE_BUFFER = 50331648,
    RTC_LEVEL_BUFFER = 67108865,
    RTC_EDGE_CREASE_INDEX_BUFFER = 83886080,
    RTC_EDGE_CREASE_WEIGHT_BUFFER = 100663296,
    RTC_VERTEX_CREASE_INDEX_BUFFER = 117440512,
    RTC_VERTEX_CREASE_WEIGHT_BUFFER = 134217728,
    RTC_HOLE_BUFFER = 150994945,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCMatrixType {
    RTC_MATRIX_ROW_MAJOR = 0,
    RTC_MATRIX_COLUMN_MAJOR = 1,
    RTC_MATRIX_COLUMN_MAJOR_ALIGNED16 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCGeometryFlags {
    RTC_GEOMETRY_STATIC = 0,
    RTC_GEOMETRY_DEFORMABLE = 1,
    RTC_GEOMETRY_DYNAMIC = 2,
}
pub const RTCBoundaryMode_RTC_BOUNDARY_EDGE_ONLY: RTCBoundaryMode =
    RTCBoundaryMode::RTC_BOUNDARY_SMOOTH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCBoundaryMode {
    RTC_BOUNDARY_NONE = 0,
    RTC_BOUNDARY_SMOOTH = 1,
    RTC_BOUNDARY_EDGE_AND_CORNER = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCSubdivisionMode {
    RTC_SUBDIV_NO_BOUNDARY = 0,
    RTC_SUBDIV_SMOOTH_BOUNDARY = 1,
    RTC_SUBDIV_PIN_CORNERS = 2,
    RTC_SUBDIV_PIN_BOUNDARY = 3,
    RTC_SUBDIV_PIN_ALL = 4,
}
pub type RTCFilterFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay)>;
pub type RTCFilterFunc4 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay4)>;
pub type RTCFilterFunc8 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay8)>;
pub type RTCFilterFunc16 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay16)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCHitN {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_RTCHitN() {
    assert_eq!(::std::mem::size_of::<RTCHitN>() , 1usize , concat ! (
               "Size of: " , stringify ! ( RTCHitN ) ));
    assert_eq! (::std::mem::align_of::<RTCHitN>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( RTCHitN ) ));
}
impl Clone for RTCHitN {
    fn clone(&self) -> Self { *self }
}
pub type RTCFilterFuncN =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *mut ::std::os::raw::c_int,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *const RTCIntersectContext,
                                               ray: *mut RTCRayN,
                                               potentialHit: *const RTCHitN,
                                               N: usize)>;
pub type RTCDisplacementFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               geomID: ::std::os::raw::c_uint,
                                               primID: ::std::os::raw::c_uint,
                                               u: *const f32, v: *const f32,
                                               nx: *const f32, ny: *const f32,
                                               nz: *const f32, px: *mut f32,
                                               py: *mut f32, pz: *mut f32,
                                               N: usize)>;
pub type RTCDisplacementFunc2 =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               geomID: ::std::os::raw::c_uint,
                                               primID: ::std::os::raw::c_uint,
                                               time: ::std::os::raw::c_uint,
                                               u: *const f32, v: *const f32,
                                               nx: *const f32, ny: *const f32,
                                               nz: *const f32, px: *mut f32,
                                               py: *mut f32, pz: *mut f32,
                                               N: usize)>;
extern "C" {
    pub fn rtcNewInstance(target: RTCScene, source: RTCScene)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewInstance2(target: RTCScene, source: RTCScene,
                           numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewInstance3(target: RTCScene, source: RTCScene,
                           numTimeSteps: usize,
                           geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewGeometryInstance(scene: RTCScene,
                                  geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewGeometryGroup(scene: RTCScene, flags: RTCGeometryFlags,
                               geomIDs: *mut ::std::os::raw::c_uint, N: usize)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcSetTransform(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                           layout: RTCMatrixType, xfm: *const f32);
}
extern "C" {
    pub fn rtcSetTransform2(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                            layout: RTCMatrixType, xfm: *const f32,
                            timeStep: usize);
}
extern "C" {
    pub fn rtcNewTriangleMesh(scene: RTCScene, flags: RTCGeometryFlags,
                              numTriangles: usize, numVertices: usize,
                              numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewTriangleMesh2(scene: RTCScene, flags: RTCGeometryFlags,
                               numTriangles: usize, numVertices: usize,
                               numTimeSteps: usize,
                               geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewQuadMesh(scene: RTCScene, flags: RTCGeometryFlags,
                          numQuads: usize, numVertices: usize,
                          numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewQuadMesh2(scene: RTCScene, flags: RTCGeometryFlags,
                           numQuads: usize, numVertices: usize,
                           numTimeSteps: usize,
                           geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewSubdivisionMesh(scene: RTCScene, flags: RTCGeometryFlags,
                                 numFaces: usize, numEdges: usize,
                                 numVertices: usize, numEdgeCreases: usize,
                                 numVertexCreases: usize, numHoles: usize,
                                 numTimeSteps: usize)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewSubdivisionMesh2(scene: RTCScene, flags: RTCGeometryFlags,
                                  numFaces: usize, numEdges: usize,
                                  numVertices: usize, numEdgeCreases: usize,
                                  numVertexCreases: usize, numHoles: usize,
                                  numTimeSteps: usize,
                                  geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewHairGeometry(scene: RTCScene, flags: RTCGeometryFlags,
                              numCurves: usize, numVertices: usize,
                              numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBezierHairGeometry(scene: RTCScene, flags: RTCGeometryFlags,
                                    numCurves: ::std::os::raw::c_uint,
                                    numVertices: ::std::os::raw::c_uint,
                                    numTimeSteps: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBezierHairGeometry2(scene: RTCScene, flags: RTCGeometryFlags,
                                     numCurves: ::std::os::raw::c_uint,
                                     numVertices: ::std::os::raw::c_uint,
                                     numTimeSteps: ::std::os::raw::c_uint,
                                     geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBSplineHairGeometry(scene: RTCScene, flags: RTCGeometryFlags,
                                     numCurves: ::std::os::raw::c_uint,
                                     numVertices: ::std::os::raw::c_uint,
                                     numTimeSteps: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBSplineHairGeometry2(scene: RTCScene,
                                      flags: RTCGeometryFlags,
                                      numCurves: ::std::os::raw::c_uint,
                                      numVertices: ::std::os::raw::c_uint,
                                      numTimeSteps: ::std::os::raw::c_uint,
                                      geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewCurveGeometry(scene: RTCScene, flags: RTCGeometryFlags,
                               numCurves: usize, numVertices: usize,
                               numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBezierCurveGeometry(scene: RTCScene, flags: RTCGeometryFlags,
                                     numCurves: ::std::os::raw::c_uint,
                                     numVertices: ::std::os::raw::c_uint,
                                     numTimeSteps: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBezierCurveGeometry2(scene: RTCScene,
                                      flags: RTCGeometryFlags,
                                      numCurves: ::std::os::raw::c_uint,
                                      numVertices: ::std::os::raw::c_uint,
                                      numTimeSteps: ::std::os::raw::c_uint,
                                      geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBSplineCurveGeometry(scene: RTCScene,
                                      flags: RTCGeometryFlags,
                                      numCurves: ::std::os::raw::c_uint,
                                      numVertices: ::std::os::raw::c_uint,
                                      numTimeSteps: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewBSplineCurveGeometry2(scene: RTCScene,
                                       flags: RTCGeometryFlags,
                                       numCurves: ::std::os::raw::c_uint,
                                       numVertices: ::std::os::raw::c_uint,
                                       numTimeSteps: ::std::os::raw::c_uint,
                                       geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewLineSegments(scene: RTCScene, flags: RTCGeometryFlags,
                              numSegments: usize, numVertices: usize,
                              numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewLineSegments2(scene: RTCScene, flags: RTCGeometryFlags,
                               numSegments: usize, numVertices: usize,
                               numTimeSteps: usize,
                               geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcSetTessellationRate(scene: RTCScene,
                                  geomID: ::std::os::raw::c_uint,
                                  tessellationRate: f32);
}
extern "C" {
    pub fn rtcSetMask(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                      mask: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rtcSetBoundaryMode(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                              mode: RTCBoundaryMode);
}
extern "C" {
    pub fn rtcSetSubdivisionMode(scene: RTCScene,
                                 geomID: ::std::os::raw::c_uint,
                                 topologyID: ::std::os::raw::c_uint,
                                 mode: RTCSubdivisionMode);
}
extern "C" {
    pub fn rtcSetIndexBuffer(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                             vertexBuffer: RTCBufferType,
                             indexBuffer: RTCBufferType);
}
extern "C" {
    pub fn rtcMapBuffer(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                        type_: RTCBufferType) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rtcUnmapBuffer(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                          type_: RTCBufferType);
}
extern "C" {
    pub fn rtcSetBuffer(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                        type_: RTCBufferType,
                        ptr: *const ::std::os::raw::c_void, byteOffset: usize,
                        byteStride: usize);
}
extern "C" {
    pub fn rtcSetBuffer2(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                         type_: RTCBufferType,
                         ptr: *const ::std::os::raw::c_void,
                         byteOffset: usize, byteStride: usize, size: usize);
}
extern "C" {
    pub fn rtcEnable(scene: RTCScene, geomID: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rtcUpdate(scene: RTCScene, geomID: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rtcUpdateBuffer(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                           type_: RTCBufferType);
}
extern "C" {
    pub fn rtcDisable(scene: RTCScene, geomID: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rtcSetDisplacementFunction(scene: RTCScene,
                                      geomID: ::std::os::raw::c_uint,
                                      func: RTCDisplacementFunc,
                                      bounds: *mut RTCBounds);
}
extern "C" {
    pub fn rtcSetDisplacementFunction2(scene: RTCScene,
                                       geomID: ::std::os::raw::c_uint,
                                       func: RTCDisplacementFunc2,
                                       bounds: *mut RTCBounds);
}
extern "C" {
    pub fn rtcSetIntersectionFilterFunction(scene: RTCScene,
                                            geomID: ::std::os::raw::c_uint,
                                            func: RTCFilterFunc);
}
extern "C" {
    pub fn rtcSetIntersectionFilterFunction4(scene: RTCScene,
                                             geomID: ::std::os::raw::c_uint,
                                             func: RTCFilterFunc4);
}
extern "C" {
    pub fn rtcSetIntersectionFilterFunction8(scene: RTCScene,
                                             geomID: ::std::os::raw::c_uint,
                                             func: RTCFilterFunc8);
}
extern "C" {
    pub fn rtcSetIntersectionFilterFunction16(scene: RTCScene,
                                              geomID: ::std::os::raw::c_uint,
                                              func: RTCFilterFunc16);
}
extern "C" {
    pub fn rtcSetIntersectionFilterFunctionN(scene: RTCScene,
                                             geomID: ::std::os::raw::c_uint,
                                             func: RTCFilterFuncN);
}
extern "C" {
    pub fn rtcSetOcclusionFilterFunction(scene: RTCScene,
                                         geomID: ::std::os::raw::c_uint,
                                         func: RTCFilterFunc);
}
extern "C" {
    pub fn rtcSetOcclusionFilterFunction4(scene: RTCScene,
                                          geomID: ::std::os::raw::c_uint,
                                          func: RTCFilterFunc4);
}
extern "C" {
    pub fn rtcSetOcclusionFilterFunction8(scene: RTCScene,
                                          geomID: ::std::os::raw::c_uint,
                                          func: RTCFilterFunc8);
}
extern "C" {
    pub fn rtcSetOcclusionFilterFunction16(scene: RTCScene,
                                           geomID: ::std::os::raw::c_uint,
                                           func: RTCFilterFunc16);
}
extern "C" {
    pub fn rtcSetOcclusionFilterFunctionN(scene: RTCScene,
                                          geomID: ::std::os::raw::c_uint,
                                          func: RTCFilterFuncN);
}
extern "C" {
    pub fn rtcSetUserData(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                          ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rtcGetUserData(scene: RTCScene, geomID: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rtcInterpolate(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                          primID: ::std::os::raw::c_uint, u: f32, v: f32,
                          buffer: RTCBufferType, P: *mut f32, dPdu: *mut f32,
                          dPdv: *mut f32, numFloats: usize);
}
extern "C" {
    pub fn rtcInterpolate2(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                           primID: ::std::os::raw::c_uint, u: f32, v: f32,
                           buffer: RTCBufferType, P: *mut f32, dPdu: *mut f32,
                           dPdv: *mut f32, ddPdudu: *mut f32,
                           ddPdvdv: *mut f32, ddPdudv: *mut f32,
                           numFloats: usize);
}
extern "C" {
    pub fn rtcInterpolateN(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                           valid: *const ::std::os::raw::c_void,
                           primIDs: *const ::std::os::raw::c_uint,
                           u: *const f32, v: *const f32, numUVs: usize,
                           buffer: RTCBufferType, P: *mut f32, dPdu: *mut f32,
                           dPdv: *mut f32, numFloats: usize);
}
extern "C" {
    pub fn rtcInterpolateN2(scene: RTCScene, geomID: ::std::os::raw::c_uint,
                            valid: *const ::std::os::raw::c_void,
                            primIDs: *const ::std::os::raw::c_uint,
                            u: *const f32, v: *const f32, numUVs: usize,
                            buffer: RTCBufferType, P: *mut f32,
                            dPdu: *mut f32, dPdv: *mut f32, ddPdudu: *mut f32,
                            ddPdvdv: *mut f32, ddPdudv: *mut f32,
                            numFloats: usize);
}
extern "C" {
    pub fn rtcDeleteGeometry(scene: RTCScene, geomID: ::std::os::raw::c_uint);
}
pub type RTCBoundsFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               item: usize,
                                               bounds_o: *mut RTCBounds)>;
pub type RTCBoundsFunc2 =
    ::std::option::Option<unsafe extern "C" fn(userPtr:
                                                   *mut ::std::os::raw::c_void,
                                               geomUserPtr:
                                                   *mut ::std::os::raw::c_void,
                                               item: usize,
                                               bounds_o: *mut RTCBounds)>;
pub type RTCBoundsFunc3 =
    ::std::option::Option<unsafe extern "C" fn(userPtr:
                                                   *mut ::std::os::raw::c_void,
                                               geomUserPtr:
                                                   *mut ::std::os::raw::c_void,
                                               item: usize, time: usize,
                                               bounds_o: *mut RTCBounds)>;
pub type RTCIntersectFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay,
                                               item: usize)>;
pub type RTCIntersectFunc4 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay4,
                                               item: usize)>;
pub type RTCIntersectFunc8 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay8,
                                               item: usize)>;
pub type RTCIntersectFunc16 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay16,
                                               item: usize)>;
pub type RTCIntersectFunc1Mp =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *const RTCIntersectContext,
                                               rays: *mut *mut RTCRay,
                                               M: usize, item: usize)>;
pub type RTCIntersectFuncN =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_int,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *const RTCIntersectContext,
                                               rays: *mut RTCRayN, N: usize,
                                               item: usize)>;
pub type RTCOccludedFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay,
                                               item: usize)>;
pub type RTCOccludedFunc4 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay4,
                                               item: usize)>;
pub type RTCOccludedFunc8 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay8,
                                               item: usize)>;
pub type RTCOccludedFunc16 =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_void,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ray: *mut RTCRay16,
                                               item: usize)>;
pub type RTCOccludedFunc1Mp =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *const RTCIntersectContext,
                                               rays: *mut *mut RTCRay,
                                               M: usize, item: usize)>;
pub type RTCOccludedFuncN =
    ::std::option::Option<unsafe extern "C" fn(valid:
                                                   *const ::std::os::raw::c_int,
                                               ptr:
                                                   *mut ::std::os::raw::c_void,
                                               context:
                                                   *const RTCIntersectContext,
                                               rays: *mut RTCRayN, N: usize,
                                               item: usize)>;
extern "C" {
    pub fn rtcNewUserGeometry(scene: RTCScene, numGeometries: usize)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewUserGeometry2(scene: RTCScene, numGeometries: usize,
                               numTimeSteps: usize) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewUserGeometry3(scene: RTCScene, gflags: RTCGeometryFlags,
                               numGeometries: usize, numTimeSteps: usize)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcNewUserGeometry4(scene: RTCScene, gflags: RTCGeometryFlags,
                               numGeometries: usize, numTimeSteps: usize,
                               geomID: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rtcSetBoundsFunction(scene: RTCScene,
                                geomID: ::std::os::raw::c_uint,
                                bounds: RTCBoundsFunc);
}
extern "C" {
    pub fn rtcSetBoundsFunction2(scene: RTCScene,
                                 geomID: ::std::os::raw::c_uint,
                                 bounds: RTCBoundsFunc2,
                                 userPtr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rtcSetBoundsFunction3(scene: RTCScene,
                                 geomID: ::std::os::raw::c_uint,
                                 bounds: RTCBoundsFunc3,
                                 userPtr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rtcSetIntersectFunction(scene: RTCScene,
                                   geomID: ::std::os::raw::c_uint,
                                   intersect: RTCIntersectFunc);
}
extern "C" {
    pub fn rtcSetIntersectFunction4(scene: RTCScene,
                                    geomID: ::std::os::raw::c_uint,
                                    intersect4: RTCIntersectFunc4);
}
extern "C" {
    pub fn rtcSetIntersectFunction8(scene: RTCScene,
                                    geomID: ::std::os::raw::c_uint,
                                    intersect8: RTCIntersectFunc8);
}
extern "C" {
    pub fn rtcSetIntersectFunction16(scene: RTCScene,
                                     geomID: ::std::os::raw::c_uint,
                                     intersect16: RTCIntersectFunc16);
}
extern "C" {
    pub fn rtcSetIntersectFunction1Mp(scene: RTCScene,
                                      geomID: ::std::os::raw::c_uint,
                                      intersect: RTCIntersectFunc1Mp);
}
extern "C" {
    pub fn rtcSetIntersectFunctionN(scene: RTCScene,
                                    geomID: ::std::os::raw::c_uint,
                                    intersect: RTCIntersectFuncN);
}
extern "C" {
    pub fn rtcSetOccludedFunction(scene: RTCScene,
                                  geomID: ::std::os::raw::c_uint,
                                  occluded: RTCOccludedFunc);
}
extern "C" {
    pub fn rtcSetOccludedFunction4(scene: RTCScene,
                                   geomID: ::std::os::raw::c_uint,
                                   occluded4: RTCOccludedFunc4);
}
extern "C" {
    pub fn rtcSetOccludedFunction8(scene: RTCScene,
                                   geomID: ::std::os::raw::c_uint,
                                   occluded8: RTCOccludedFunc8);
}
extern "C" {
    pub fn rtcSetOccludedFunction16(scene: RTCScene,
                                    geomID: ::std::os::raw::c_uint,
                                    occluded16: RTCOccludedFunc16);
}
extern "C" {
    pub fn rtcSetOccludedFunction1Mp(scene: RTCScene,
                                     geomID: ::std::os::raw::c_uint,
                                     occluded: RTCOccludedFunc1Mp);
}
extern "C" {
    pub fn rtcSetOccludedFunctionN(scene: RTCScene,
                                   geomID: ::std::os::raw::c_uint,
                                   occluded: RTCOccludedFuncN);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __RTCBVH {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___RTCBVH() {
    assert_eq!(::std::mem::size_of::<__RTCBVH>() , 1usize , concat ! (
               "Size of: " , stringify ! ( __RTCBVH ) ));
    assert_eq! (::std::mem::align_of::<__RTCBVH>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( __RTCBVH ) ));
}
impl Clone for __RTCBVH {
    fn clone(&self) -> Self { *self }
}
pub type RTCBVH = *mut __RTCBVH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __RTCThreadLocalAllocator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout___RTCThreadLocalAllocator() {
    assert_eq!(::std::mem::size_of::<__RTCThreadLocalAllocator>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( __RTCThreadLocalAllocator ) ));
    assert_eq! (::std::mem::align_of::<__RTCThreadLocalAllocator>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( __RTCThreadLocalAllocator )
                ));
}
impl Clone for __RTCThreadLocalAllocator {
    fn clone(&self) -> Self { *self }
}
pub type RTCThreadLocalAllocator = *mut __RTCThreadLocalAllocator;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTCBuildQuality {
    RTC_BUILD_QUALITY_LOW = 0,
    RTC_BUILD_QUALITY_NORMAL = 1,
    RTC_BUILD_QUALITY_HIGH = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCBuildSettings {
    pub size: ::std::os::raw::c_uint,
    pub quality: RTCBuildQuality,
    pub maxBranchingFactor: ::std::os::raw::c_uint,
    pub maxDepth: ::std::os::raw::c_uint,
    pub sahBlockSize: ::std::os::raw::c_uint,
    pub minLeafSize: ::std::os::raw::c_uint,
    pub maxLeafSize: ::std::os::raw::c_uint,
    pub travCost: f32,
    pub intCost: f32,
    pub extraSpace: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_RTCBuildSettings() {
    assert_eq!(::std::mem::size_of::<RTCBuildSettings>() , 40usize , concat !
               ( "Size of: " , stringify ! ( RTCBuildSettings ) ));
    assert_eq! (::std::mem::align_of::<RTCBuildSettings>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( RTCBuildSettings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . quality as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . maxBranchingFactor
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( maxBranchingFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . maxDepth as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( maxDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . sahBlockSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( sahBlockSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . minLeafSize as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( minLeafSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . maxLeafSize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( maxLeafSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . travCost as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( travCost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . intCost as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( intCost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildSettings ) ) . extraSpace as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildSettings ) ,
                "::" , stringify ! ( extraSpace ) ));
}
impl Clone for RTCBuildSettings {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RTCBuildPrimitive {
    pub lower_x: f32,
    pub lower_y: f32,
    pub lower_z: f32,
    pub geomID: ::std::os::raw::c_int,
    pub upper_x: f32,
    pub upper_y: f32,
    pub upper_z: f32,
    pub primID: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RTCBuildPrimitive() {
    assert_eq!(::std::mem::size_of::<RTCBuildPrimitive>() , 32usize , concat !
               ( "Size of: " , stringify ! ( RTCBuildPrimitive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . lower_x as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( lower_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . lower_y as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( lower_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . lower_z as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( lower_z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . geomID as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( geomID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . upper_x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( upper_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . upper_y as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( upper_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . upper_z as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( upper_z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RTCBuildPrimitive ) ) . primID as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( RTCBuildPrimitive ) ,
                "::" , stringify ! ( primID ) ));
}
impl Clone for RTCBuildPrimitive {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rtcNewBVH(device: RTCDevice) -> RTCBVH;
}
pub type RTCCreateNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(allocator:
                                                   RTCThreadLocalAllocator,
                                               numChildren: usize,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type RTCSetNodeChildrenFunc =
    ::std::option::Option<unsafe extern "C" fn(nodePtr:
                                                   *mut ::std::os::raw::c_void,
                                               children:
                                                   *mut *mut ::std::os::raw::c_void,
                                               numChildren: usize,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)>;
pub type RTCSetNodeBoundsFunc =
    ::std::option::Option<unsafe extern "C" fn(nodePtr:
                                                   *mut ::std::os::raw::c_void,
                                               bounds: *mut *const RTCBounds,
                                               numChildren: usize,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)>;
pub type RTCCreateLeafFunc =
    ::std::option::Option<unsafe extern "C" fn(allocator:
                                                   RTCThreadLocalAllocator,
                                               prims:
                                                   *const RTCBuildPrimitive,
                                               numPrims: usize,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type RTCSplitPrimitiveFunc =
    ::std::option::Option<unsafe extern "C" fn(prim: *const RTCBuildPrimitive,
                                               dim: ::std::os::raw::c_uint,
                                               pos: f32,
                                               lbounds: *mut RTCBounds,
                                               rbounds: *mut RTCBounds,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)>;
pub type RTCBuildProgressFunc =
    ::std::option::Option<unsafe extern "C" fn(dn: usize,
                                               userPtr:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn rtcBuildBVH(bvh: RTCBVH, settings: *const RTCBuildSettings,
                       primitives: *mut RTCBuildPrimitive,
                       numPrimitives: usize, createNode: RTCCreateNodeFunc,
                       setNodeChildren: RTCSetNodeChildrenFunc,
                       setNodeBounds: RTCSetNodeBoundsFunc,
                       createLeaf: RTCCreateLeafFunc,
                       splitPrimitive: RTCSplitPrimitiveFunc,
                       buildProgress: RTCBuildProgressFunc,
                       userPtr: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rtcThreadLocalAlloc(allocator: RTCThreadLocalAllocator,
                               bytes: usize, align: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rtcMakeStaticBVH(bvh: RTCBVH);
}
extern "C" {
    pub fn rtcDeleteBVH(bvh: RTCBVH);
}
